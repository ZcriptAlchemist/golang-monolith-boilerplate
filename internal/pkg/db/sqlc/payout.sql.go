// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: payout.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const listAllPayouts = `-- name: ListAllPayouts :many
SELECT id, crn, account_number, transaction_status, created_at FROM payouts ORDER BY crn ASC
`

func (q *Queries) ListAllPayouts(ctx context.Context) ([]Payout, error) {
	rows, err := q.db.Query(ctx, listAllPayouts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payout
	for rows.Next() {
		var i Payout
		if err := rows.Scan(
			&i.ID,
			&i.Crn,
			&i.AccountNumber,
			&i.TransactionStatus,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllPendingPayouts = `-- name: ListAllPendingPayouts :many
SELECT created_at, crn, transaction_status from payouts where transaction_status = 'pending' ORDER BY created_at ASC
`

type ListAllPendingPayoutsRow struct {
	CreatedAt         pgtype.Timestamp
	Crn               pgtype.Int4
	TransactionStatus string
}

func (q *Queries) ListAllPendingPayouts(ctx context.Context) ([]ListAllPendingPayoutsRow, error) {
	rows, err := q.db.Query(ctx, listAllPendingPayouts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllPendingPayoutsRow
	for rows.Next() {
		var i ListAllPendingPayoutsRow
		if err := rows.Scan(&i.CreatedAt, &i.Crn, &i.TransactionStatus); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
